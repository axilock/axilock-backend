// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: alert.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createAlertConfig = `-- name: CreateAlertConfig :one
INSERT INTO alert_config (
    org, type, severity, matcher, regex, "desc", is_active, alert_type )
VALUES ( $1, $2, $3, $4, $5, $6, $7, $8 ) RETURNING id
`

type CreateAlertConfigParams struct {
	Org       int64       `json:"org"`
	Type      string      `json:"type"`
	Severity  string      `json:"severity"`
	Matcher   string      `json:"matcher"`
	Regex     pgtype.Text `json:"regex"`
	Desc      pgtype.Text `json:"desc"`
	IsActive  pgtype.Bool `json:"is_active"`
	AlertType string      `json:"alert_type"`
}

// CreateAlertConfig
//
//	INSERT INTO alert_config (
//	    org, type, severity, matcher, regex, "desc", is_active, alert_type )
//	VALUES ( $1, $2, $3, $4, $5, $6, $7, $8 ) RETURNING id
func (q *Queries) CreateAlertConfig(ctx context.Context, arg CreateAlertConfigParams) (int64, error) {
	row := q.db.QueryRow(ctx, createAlertConfig,
		arg.Org,
		arg.Type,
		arg.Severity,
		arg.Matcher,
		arg.Regex,
		arg.Desc,
		arg.IsActive,
		arg.AlertType,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createSecretAlert = `-- name: CreateSecretAlert :exec
INSERT INTO alerts (
    file_name, commit_id, source, status, file_path, alert_config_id, org_id)
VALUES ( $1, $2, $3, $4, $5, $6, $7 )
`

type CreateSecretAlertParams struct {
	FileName      string `json:"file_name"`
	CommitID      int64  `json:"commit_id"`
	Source        string `json:"source"`
	Status        string `json:"status"`
	FilePath      string `json:"file_path"`
	AlertConfigID int64  `json:"alert_config_id"`
	OrgID         int64  `json:"org_id"`
}

// CreateSecretAlert
//
//	INSERT INTO alerts (
//	    file_name, commit_id, source, status, file_path, alert_config_id, org_id)
//	VALUES ( $1, $2, $3, $4, $5, $6, $7 )
func (q *Queries) CreateSecretAlert(ctx context.Context, arg CreateSecretAlertParams) error {
	_, err := q.db.Exec(ctx, createSecretAlert,
		arg.FileName,
		arg.CommitID,
		arg.Source,
		arg.Status,
		arg.FilePath,
		arg.AlertConfigID,
		arg.OrgID,
	)
	return err
}

const getAlertBuckets = `-- name: GetAlertBuckets :many
WITH all_severities AS (
    SELECT 'critical' AS severity
    UNION ALL
    SELECT 'high'
    UNION ALL
    SELECT 'medium'
    UNION ALL
    SELECT 'low'
),
historical_total AS (
  SELECT
    s.severity,
    (
      SELECT COUNT(*)
      FROM alerts a
      INNER JOIN alert_config ac ON a.alert_config_id = ac.id
      WHERE 
        ac.severity = s.severity
        AND a.org_id = $1
        AND a.created_at < (current_date - INTERVAL '1 MONTH')
    ) AS total_prior_alerts
  FROM all_severities s
),
all_buckets AS (
  SELECT 
    generated_time AS bucket_start,
    LEAST( -- for last bucket
      generated_time + INTERVAL '4 days' - INTERVAL '1 second',
      current_date + INTERVAL '1 days' - INTERVAL '1 second'
    ) AS bucket_end
  FROM generate_series(
    current_date - INTERVAL '1 MONTH',
    current_date,
    '4 days'::interval
  ) AS generated_time
),
recent_buckets_data AS (
  SELECT
    (date_bin(
      '4 days',
      a.created_at,
      current_date - INTERVAL '1 MONTH'
    ) + INTERVAL '4 days' - INTERVAL '1 second') AS bucket_end,
    ac.severity,
    COUNT(*) AS alert_count
  FROM alerts a
  INNER JOIN alert_config ac ON a.alert_config_id = ac.id
  WHERE
    a.org_id = $1
    AND a.created_at >= (current_date - INTERVAL '1 MONTH')
  GROUP BY bucket_end, ac.severity
),
recent_buckets AS (
  SELECT
    b.bucket_end,
    s.severity,
    COALESCE(r.alert_count, 0) AS alert_count
  FROM all_buckets b
  CROSS JOIN all_severities s
  LEFT JOIN recent_buckets_data r 
    ON b.bucket_end = r.bucket_end AND s.severity = r.severity
  WHERE b.bucket_end <= current_date + INTERVAL '1 day' - INTERVAL '1 second'  -- Ensure no future buckets
)
SELECT
  rb.bucket_end,
  rb.severity,
  rb.alert_count AS period_count,
  (
    SUM(rb.alert_count) OVER (
    PARTITION BY rb.severity
    ORDER BY rb.bucket_end
    ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
    ) + COALESCE(ht.total_prior_alerts, 0)
  )::bigint AS cumulative_count
FROM recent_buckets rb
LEFT JOIN historical_total ht USING (severity)
ORDER BY rb.bucket_end, rb.severity
`

type GetAlertBucketsRow struct {
	BucketEnd       interface{} `json:"bucket_end"`
	Severity        string      `json:"severity"`
	PeriodCount     int64       `json:"period_count"`
	CumulativeCount int64       `json:"cumulative_count"`
}

// GetAlertBuckets
//
//	WITH all_severities AS (
//	    SELECT 'critical' AS severity
//	    UNION ALL
//	    SELECT 'high'
//	    UNION ALL
//	    SELECT 'medium'
//	    UNION ALL
//	    SELECT 'low'
//	),
//	historical_total AS (
//	  SELECT
//	    s.severity,
//	    (
//	      SELECT COUNT(*)
//	      FROM alerts a
//	      INNER JOIN alert_config ac ON a.alert_config_id = ac.id
//	      WHERE
//	        ac.severity = s.severity
//	        AND a.org_id = $1
//	        AND a.created_at < (current_date - INTERVAL '1 MONTH')
//	    ) AS total_prior_alerts
//	  FROM all_severities s
//	),
//	all_buckets AS (
//	  SELECT
//	    generated_time AS bucket_start,
//	    LEAST( -- for last bucket
//	      generated_time + INTERVAL '4 days' - INTERVAL '1 second',
//	      current_date + INTERVAL '1 days' - INTERVAL '1 second'
//	    ) AS bucket_end
//	  FROM generate_series(
//	    current_date - INTERVAL '1 MONTH',
//	    current_date,
//	    '4 days'::interval
//	  ) AS generated_time
//	),
//	recent_buckets_data AS (
//	  SELECT
//	    (date_bin(
//	      '4 days',
//	      a.created_at,
//	      current_date - INTERVAL '1 MONTH'
//	    ) + INTERVAL '4 days' - INTERVAL '1 second') AS bucket_end,
//	    ac.severity,
//	    COUNT(*) AS alert_count
//	  FROM alerts a
//	  INNER JOIN alert_config ac ON a.alert_config_id = ac.id
//	  WHERE
//	    a.org_id = $1
//	    AND a.created_at >= (current_date - INTERVAL '1 MONTH')
//	  GROUP BY bucket_end, ac.severity
//	),
//	recent_buckets AS (
//	  SELECT
//	    b.bucket_end,
//	    s.severity,
//	    COALESCE(r.alert_count, 0) AS alert_count
//	  FROM all_buckets b
//	  CROSS JOIN all_severities s
//	  LEFT JOIN recent_buckets_data r
//	    ON b.bucket_end = r.bucket_end AND s.severity = r.severity
//	  WHERE b.bucket_end <= current_date + INTERVAL '1 day' - INTERVAL '1 second'  -- Ensure no future buckets
//	)
//	SELECT
//	  rb.bucket_end,
//	  rb.severity,
//	  rb.alert_count AS period_count,
//	  (
//	    SUM(rb.alert_count) OVER (
//	    PARTITION BY rb.severity
//	    ORDER BY rb.bucket_end
//	    ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
//	    ) + COALESCE(ht.total_prior_alerts, 0)
//	  )::bigint AS cumulative_count
//	FROM recent_buckets rb
//	LEFT JOIN historical_total ht USING (severity)
//	ORDER BY rb.bucket_end, rb.severity
func (q *Queries) GetAlertBuckets(ctx context.Context, orgID int64) ([]GetAlertBucketsRow, error) {
	rows, err := q.db.Query(ctx, getAlertBuckets, orgID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAlertBucketsRow{}
	for rows.Next() {
		var i GetAlertBucketsRow
		if err := rows.Scan(
			&i.BucketEnd,
			&i.Severity,
			&i.PeriodCount,
			&i.CumulativeCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAlertConfigByName = `-- name: GetAlertConfigByName :one
SELECT id FROM alert_config 
WHERE org = $1
AND type = $2
LIMIT 1
`

type GetAlertConfigByNameParams struct {
	Org  int64  `json:"org"`
	Type string `json:"type"`
}

// GetAlertConfigByName
//
//	SELECT id FROM alert_config
//	WHERE org = $1
//	AND type = $2
//	LIMIT 1
func (q *Queries) GetAlertConfigByName(ctx context.Context, arg GetAlertConfigByNameParams) (int64, error) {
	row := q.db.QueryRow(ctx, getAlertConfigByName, arg.Org, arg.Type)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getSecretTypeCount = `-- name: GetSecretTypeCount :many
SELECT
    ac.type,
    COUNT(a.id) AS count
FROM
    alerts a
JOIN
    alert_config ac ON a.alert_config_id = ac.id
WHERE
    a.org_id = $1
GROUP BY
    ac.type
ORDER BY
    count DESC
`

type GetSecretTypeCountRow struct {
	Type  string `json:"type"`
	Count int64  `json:"count"`
}

// GetSecretTypeCount
//
//	SELECT
//	    ac.type,
//	    COUNT(a.id) AS count
//	FROM
//	    alerts a
//	JOIN
//	    alert_config ac ON a.alert_config_id = ac.id
//	WHERE
//	    a.org_id = $1
//	GROUP BY
//	    ac.type
//	ORDER BY
//	    count DESC
func (q *Queries) GetSecretTypeCount(ctx context.Context, orgID int64) ([]GetSecretTypeCountRow, error) {
	rows, err := q.db.Query(ctx, getSecretTypeCount, orgID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSecretTypeCountRow{}
	for rows.Next() {
		var i GetSecretTypeCountRow
		if err := rows.Scan(&i.Type, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTotalAlertCount = `-- name: GetTotalAlertCount :one
SELECT COUNT(*) AS count
FROM alerts
WHERE org_id = $1
`

// GetTotalAlertCount
//
//	SELECT COUNT(*) AS count
//	FROM alerts
//	WHERE org_id = $1
func (q *Queries) GetTotalAlertCount(ctx context.Context, orgID int64) (int64, error) {
	row := q.db.QueryRow(ctx, getTotalAlertCount, orgID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getWeeklyStats = `-- name: GetWeeklyStats :one



SELECT 
    r.id AS repo_id,
    r.name AS repo_name,
    COUNT(a.id) AS alert_count
FROM 
    repos r
JOIN 
    commits_cli cc ON r.id = cc.repo
JOIN 
    alerts a ON cc.id = a.commit_id
WHERE 
    r.org = $1
GROUP BY 
    r.id, r.name
ORDER BY 
    alert_count DESC
LIMIT 10
`

type GetWeeklyStatsRow struct {
	RepoID     int64  `json:"repo_id"`
	RepoName   string `json:"repo_name"`
	AlertCount int64  `json:"alert_count"`
}

// -- name: GetAlertForEntity :many
// SELECT * FROM alerts
// WHERE org_id = COALESCE(sqlc.narg(org_id), org_id) AND
// repo_id = COALESCE(sqlc.narg(repo_id), repo_id) AND
// status =  COALESCE(sqlc.narg(status), status)
// LIMIT sqlc.arg(count);
// WITH org_metrics AS (
//
//	SELECT
//	    COUNT(*) FILTER (WHERE created_at >= CURRENT_DATE - INTERVAL '7 days') AS recent_count,
//	    COUNT(*) FILTER (WHERE source = 'axi-cli') AS protected_count,
//	    COUNT(*) FILTER (WHERE source = 'axi-runner') AS bypassed_count
//	FROM
//	    alerts
//	WHERE
//	    org = $1
//
// )
// SELECT
//
//	COALESCE(m.recent_count, 0) AS alerts_last_7_days,
//	COALESCE(m.protected_count, 0) AS alerts_protected,
//	COALESCE(m.bypassed_count, 0) AS alerts_bypassed
//
// FROM
//
//	organisations o
//
// CROSS JOIN
//
//	org_metrics m
//
// WHERE
//
//	   o.id = $1;
//
//
//
//
//	SELECT
//	    r.id AS repo_id,
//	    r.name AS repo_name,
//	    COUNT(a.id) AS alert_count
//	FROM
//	    repos r
//	JOIN
//	    commits_cli cc ON r.id = cc.repo
//	JOIN
//	    alerts a ON cc.id = a.commit_id
//	WHERE
//	    r.org = $1
//	GROUP BY
//	    r.id, r.name
//	ORDER BY
//	    alert_count DESC
//	LIMIT 10
func (q *Queries) GetWeeklyStats(ctx context.Context, org int64) (GetWeeklyStatsRow, error) {
	row := q.db.QueryRow(ctx, getWeeklyStats, org)
	var i GetWeeklyStatsRow
	err := row.Scan(&i.RepoID, &i.RepoName, &i.AlertCount)
	return i, err
}

const top10RepoBySecretCount = `-- name: Top10RepoBySecretCount :many
SELECT
    r.repourl AS repo_name,
    COUNT(a.id) AS secret_count
FROM
    repos r
JOIN
    commit_webhooks cw ON r.id = cw.repo_id
JOIN
    alerts a ON cw.id = a.commit_id
JOIN
    alert_config ac ON a.alert_config_id = ac.id
WHERE
    ac.alert_type = 'secret'
    AND r.org = $1
GROUP BY
    r.repourl
ORDER BY
    secret_count DESC
LIMIT 10
`

type Top10RepoBySecretCountRow struct {
	RepoName    string `json:"repo_name"`
	SecretCount int64  `json:"secret_count"`
}

// Top10RepoBySecretCount
//
//	SELECT
//	    r.repourl AS repo_name,
//	    COUNT(a.id) AS secret_count
//	FROM
//	    repos r
//	JOIN
//	    commit_webhooks cw ON r.id = cw.repo_id
//	JOIN
//	    alerts a ON cw.id = a.commit_id
//	JOIN
//	    alert_config ac ON a.alert_config_id = ac.id
//	WHERE
//	    ac.alert_type = 'secret'
//	    AND r.org = $1
//	GROUP BY
//	    r.repourl
//	ORDER BY
//	    secret_count DESC
//	LIMIT 10
func (q *Queries) Top10RepoBySecretCount(ctx context.Context, org int64) ([]Top10RepoBySecretCountRow, error) {
	rows, err := q.db.Query(ctx, top10RepoBySecretCount, org)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Top10RepoBySecretCountRow{}
	for rows.Next() {
		var i Top10RepoBySecretCountRow
		if err := rows.Scan(&i.RepoName, &i.SecretCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
