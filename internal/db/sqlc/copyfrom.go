// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: copyfrom.go

package db

import (
	"context"
)

// iteratorForCreateCommmitsFromRPC implements pgx.CopyFromSource.
type iteratorForCreateCommmitsFromRPC struct {
	rows                 []CreateCommmitsFromRPCParams
	skippedFirstNextCall bool
}

func (r *iteratorForCreateCommmitsFromRPC) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForCreateCommmitsFromRPC) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].CommitID,
		r.rows[0].Repo,
		r.rows[0].Author,
		r.rows[0].CommitTime,
		r.rows[0].Org,
		r.rows[0].UserID,
		r.rows[0].PushTime,
		r.rows[0].Sessionid,
		r.rows[0].Source,
		r.rows[0].UserRepoUrl,
	}, nil
}

func (r iteratorForCreateCommmitsFromRPC) Err() error {
	return nil
}

// CreateCommmitsFromRPC
//
//	INSERT INTO commits_cli (
//	  commit_id, repo, author, commit_time, org, user_id,
//	  push_time, sessionid, source, user_repo_url
//	) VALUES (
//	    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
//	)
func (q *Queries) CreateCommmitsFromRPC(ctx context.Context, arg []CreateCommmitsFromRPCParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"commits_cli"}, []string{"commit_id", "repo", "author", "commit_time", "org", "user_id", "push_time", "sessionid", "source", "user_repo_url"}, &iteratorForCreateCommmitsFromRPC{rows: arg})
}

// iteratorForCreateRepoWithProvider implements pgx.CopyFromSource.
type iteratorForCreateRepoWithProvider struct {
	rows                 []CreateRepoWithProviderParams
	skippedFirstNextCall bool
}

func (r *iteratorForCreateRepoWithProvider) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForCreateRepoWithProvider) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].Name,
		r.rows[0].Repourl,
		r.rows[0].Provider,
		r.rows[0].Org,
		r.rows[0].VcsRepoID,
	}, nil
}

func (r iteratorForCreateRepoWithProvider) Err() error {
	return nil
}

// CreateRepoWithProvider
//
//	INSERT INTO repos (
//	    name, repourl, provider, org, vcs_repo_id)
//	VALUES ( $1, $2, $3, $4, $5)
func (q *Queries) CreateRepoWithProvider(ctx context.Context, arg []CreateRepoWithProviderParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"repos"}, []string{"name", "repourl", "provider", "org", "vcs_repo_id"}, &iteratorForCreateRepoWithProvider{rows: arg})
}

// iteratorForCreateUserForGithub implements pgx.CopyFromSource.
type iteratorForCreateUserForGithub struct {
	rows                 []CreateUserForGithubParams
	skippedFirstNextCall bool
}

func (r *iteratorForCreateUserForGithub) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForCreateUserForGithub) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].Org,
		r.rows[0].GithubUserID,
		r.rows[0].GithubUserName,
		r.rows[0].Email,
		r.rows[0].HashPassword,
		r.rows[0].Provider,
	}, nil
}

func (r iteratorForCreateUserForGithub) Err() error {
	return nil
}

// CreateUserForGithub
//
//	INSERT INTO users (
//	  org, github_user_id, github_user_name, email, hash_password, provider
//	) VALUES (
//	  $1, $2, $3, $4, $5, $6
//	)
func (q *Queries) CreateUserForGithub(ctx context.Context, arg []CreateUserForGithubParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"users"}, []string{"org", "github_user_id", "github_user_name", "email", "hash_password", "provider"}, &iteratorForCreateUserForGithub{rows: arg})
}

// iteratorForCreateVCSCommit implements pgx.CopyFromSource.
type iteratorForCreateVCSCommit struct {
	rows                 []CreateVCSCommitParams
	skippedFirstNextCall bool
}

func (r *iteratorForCreateVCSCommit) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForCreateVCSCommit) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].CommitID,
		r.rows[0].RepoID,
		r.rows[0].AuthorName,
		r.rows[0].AuthorEmail,
		r.rows[0].CommitTime,
		r.rows[0].Org,
		r.rows[0].Provider,
		r.rows[0].ScannedByCli,
		r.rows[0].ScannedByRunner,
	}, nil
}

func (r iteratorForCreateVCSCommit) Err() error {
	return nil
}

// CreateVCSCommit
//
//	INSERT INTO commit_webhooks (
//	  commit_id, repo_id, author_name, author_email, commit_time, org, provider , scanned_by_cli,
//	  scanned_by_runner
//	) VALUES (
//	    $1, $2, $3, $4, $5, $6, $7, $8, $9
//	)
func (q *Queries) CreateVCSCommit(ctx context.Context, arg []CreateVCSCommitParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"commit_webhooks"}, []string{"commit_id", "repo_id", "author_name", "author_email", "commit_time", "org", "provider", "scanned_by_cli", "scanned_by_runner"}, &iteratorForCreateVCSCommit{rows: arg})
}
